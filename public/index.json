
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"Understanding the difference between JavaScript’s == (loose equality) and === (strict equality) operators is crucial for writing reliable and predictable code. These operators are used to compare values, but they behave differently when it comes to type conversion.\nLoose Equality (==) The == operator compares two values for equality, performing type conversion if necessary. This means that if the values are of different types, JavaScript will attempt to convert them to a common type before making the comparison. While this can be convenient, it may lead to unexpected results due to implicit type coercion.\nExample 1: Comparing a number and a string\nlet a = 5; let b = \u0026#39;5\u0026#39;; console.log(a == b); // Output: true In this case, JavaScript converts the string \u0026#39;5\u0026#39; to the number 5 before making the comparison, resulting in true.\nExample 2: Comparing a boolean and a number\nlet x = 0; let y = false; console.log(x == y); // Output: true Here, false is coerced to 0, so the comparison evaluates to true.\nExample 3: Comparing null and undefined\nconsole.log(null == undefined); // Output: true JavaScript considers null and undefined equal when using ==, even though they are different types.\nStrict Equality (===) The === operator compares both the value and the type of the operands without performing any type conversion. For the comparison to return true, both the value and the type must be the same.\nExample 1: Comparing a number and a string\nlet a = 5; let b = \u0026#39;5\u0026#39;; console.log(a === b); // Output: false Since a is a number and b is a string, the comparison returns false because their types differ.\nExample 2: Comparing two identical strings\nlet str1 = \u0026#39;hello\u0026#39;; let str2 = \u0026#39;hello\u0026#39;; console.log(str1 === str2); // Output: true Both the value and type match, so the comparison returns true.\nExample 3: Comparing null and undefined\nconsole.log(null === undefined); // Output: false With ===, null and undefined are not considered equal because they are of different types.\nKey Differences Type Conversion: == performs type conversion to match the types before comparison, which can lead to unexpected results. === does not perform type conversion; both the value and type must match for the comparison to return true.\nPredictability: Using === is generally more predictable and less error-prone because it doesn’t involve implicit type coercion.\nBest Practices It’s advisable to use === (strict equality) over == (loose equality) to avoid unexpected type coercion issues. This practice leads to more reliable and maintainable code.\nFor more detailed information on equality comparisons in JavaScript, you can refer to the MDN Web Docs.\n","date":1743050382,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050677,"objectID":"5f446f833604e8d087c0cb9b66d3997c","permalink":"http://localhost:1313/post/what-is-the-triple-equal-operator-in-javascript/","publishdate":"2025-03-27T12:39:42+08:00","relpermalink":"/post/what-is-the-triple-equal-operator-in-javascript/","section":"post","summary":"Understanding the difference between JavaScript's == (loose equality) and === (strict equality) operators in javascript.","tags":["Programming","Javascript"],"title":"What Is the Triple Equal Operator in Javascript?","type":"post"},{"authors":null,"categories":null,"content":"Fixing “iwlwifi failed with error -110” on Linux After Dual Booting Dual booting Windows and Linux can be a great way to enjoy the best of both worlds. However, if you’re experiencing issues with your Intel Wi‑Fi card on Linux—especially when switching from Windows—the error message below might look familiar in your system logs:\n[ 6.397335] iwlwifi 0000:02:00.0: probe with driver iwlwifi failed with error -110 In this post, we’ll explore what this error means, why it may occur in a dual-boot setup, and a simple fix that worked for me.\nWhat Does “Error -110” Mean? When you see an error like this in your dmesg output, it tells you that the iwlwifi driver isn’t able to initialize your Intel Wireless 8265/8275 card properly. The “-110” error is often related to a hardware or power management issue. In many cases, this can happen because Windows leaves the Wi‑Fi card in a low-power or “hibernated” state if its Fast Startup feature is enabled.\nWhy Dual Boot Can Cause Wi‑Fi Problems Fast Startup in Windows:\nWindows Fast Startup (sometimes called Fast Boot) is designed to speed up the boot process by not completely shutting down the system. Instead, Windows saves some system state to disk so that the next boot is faster. While this feature can be helpful for Windows users, it may prevent your Wi‑Fi card from fully resetting its power state when you switch over to Linux. As a result, Linux may not detect or initialize the card correctly, triggering the error.\nWhat Happens in Linux:\nWhen you boot directly into Linux after using Windows, the leftover power state or “hibernation” mode on your Wi‑Fi hardware can lead to the driver failing its probe (or initialization), hence the error message we saw. Interestingly, if you boot into Windows first (which resets the hardware properly) and then switch to Linux, the card works fine.\nThe Simple Fix: Disable Windows Fast Startup After some troubleshooting, I discovered that disabling Windows Fast Startup resolved the problem permanently. Here’s how you can do it:\nBoot into Windows 10:\nOpen the Control Panel and go to Power Options. You can press Win + R, type control panel, and hit Enter to open it. Alternatively, if you’re using a laptop, you can right-click the battery icon in the taskbar to access power settings.\nAccess Shutdown Settings:\nClick on “Choose what the power buttons do” on the left-hand side.\nThen click on “Change settings that are currently unavailable” at the top.\nDisable Fast Startup:\nUnder the Shutdown settings section, uncheck the box next to “Turn on fast startup (recommended)”.\nSave and Reboot:\nClick Save changes and restart your computer.\nOnce you’ve disabled Fast Startup, the Wi‑Fi card resets fully when shutting down, allowing Linux to initialize it properly during boot. Now, when you check your system logs (using dmesg), the error should no longer appear, and your wireless connections should work without a hitch.\nHow to Confirm the Fix After making the changes, boot into Linux and run:\nsudo dmesg | grep -i iwlwifi If you no longer see the error message and your wireless interface appears in the output of:\nnmcli device status then you know the issue is resolved!\nIn Conclusion Dual boot setups can sometimes bring unexpected challenges, especially when different operating systems manage hardware power states in different ways. Disabling Windows Fast Startup is a simple and effective solution to the “iwlwifi failed with error -110” issue. By ensuring that your hardware resets completely during shutdown, you help Linux initialize your Wi‑Fi card correctly every time.\nIf you found this post helpful, feel free to share it with others who might be facing the same problem!\nHappy dual booting, and may your connections always be strong!\n","date":1742967852,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050434,"objectID":"cf6f9ff40516a96302b0443b4b73bf65","permalink":"http://localhost:1313/post/wififix/","publishdate":"2025-03-26T13:44:12+08:00","relpermalink":"/post/wififix/","section":"post","summary":"Fixing “iwlwifi failed with error -110” on Linux After Dual Booting with windows 10/11","tags":["Linux","Wifi"],"title":"Fixing 'iwlwifi failed with error -110' on Linux After Dual Boot with Windows","type":"post"},{"authors":null,"categories":null,"content":"Introduction Algorithms are step-by-step instructions designed to solve problems. They are the foundation of programming and computer science. Whether you’re sorting numbers, searching for data, or making a game character move, algorithms are everywhere.\nTo express algorithms clearly, we often use pseudocode—a simplified way to write logic without focusing on specific programming language syntax.\nIn this post, we’ll explore both simple and complex algorithms using pseudocode.\nSimple Example: Finding the Maximum of Two Numbers Let’s start with a basic problem: finding the larger of two numbers.\nPseudocode: Algorithm FindMax(A, B): If A \u0026gt; B Then Return A Else Return B Explanation: Compare A and B. Return the larger one. Example Execution: Input: A = 5, B = 9 Output: 9 More Complex Example: Bubble Sort Now, let’s look at something more challenging—Bubble Sort, an algorithm that sorts a list by repeatedly swapping adjacent elements if they are in the wrong order.\nPseudocode: Algorithm BubbleSort(Array): N = length of Array Repeat N-1 times: For i from 0 to N-2: If Array[i] \u0026gt; Array[i+1] Then Swap(Array[i], Array[i+1]) Explanation: Loop through the list multiple times. Compare adjacent elements. Swap them if they are in the wrong order. Repeat until the list is sorted. Example Execution: Input: [5, 3, 8, 4, 2]\nIterations: [3, 5, 4, 2, 8] [3, 4, 2, 5, 8] [3, 2, 4, 5, 8] [2, 3, 4, 5, 8] (Sorted!) Complexity: Worst case: O(n²) Best case (already sorted list): O(n) Conclusion Algorithms range from simple comparisons to complex sorting techniques. Learning to express them in pseudocode makes it easier to understand their logic before implementing them in programming languages.\nWant to learn more? Try implementing these in Python, Java, or C++!\n","date":1742649703,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050441,"objectID":"1441addfd4c611a506ab0108c90e180a","permalink":"http://localhost:1313/post/algo/","publishdate":"2025-03-22T21:21:43+08:00","relpermalink":"/post/algo/","section":"post","summary":"A beginner-friendly guide to understanding algorithms and pseudocode, with simple and complex examples.","tags":["Algorithm","Pseudocode"],"title":"Understanding Algorithms and Pseudocode","type":"post"}]