
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"Number Theory (A.K.A. Higher Arithmetic) A branch of mathematics concerned with the properties of integers.\nDivisibility Divisibility means dividing one number evenly by another, without leaving a remainder.\n$d \\mid n$ means that $d$ divides $n$ $d \\nmid n$ means that $d$ does not divide $n$ Conditions: $d \\neq 0$ $n \\neq 0$ If $d \\times q = n$, then $q = \\frac{n}{d}$ Divisibility Rules Rule for 2 A number is divisible by 2 if its last digit is even (i.e. 0, 2, 4, 6, or 8).\nExamples:\n$2 \\mid 128$ → 8 is even ⇒ ✅ $2 \\nmid 129$ → 9 is odd ⇒ ❌ Rule for 3 A number is divisible by 3 if the sum of its digits is divisible by 3.\nExamples:\n$3 \\mid 381$:\n$3 + 8 + 1 = 12$ → $3 \\mid 12$ ⇒ ✅ $3 \\nmid 217$:\n$2 + 1 + 7 = 10$ → $3 \\nmid 10$ ⇒ ❌ Rule for 4 A number is divisible by 4 if the last two digits form a number divisible by 4.\nExamples:\n$4 \\mid 1312$:\nLast two digits: 12 → $4 \\mid 12$ ⇒ ✅ $4 \\nmid 7019$:\nLast two digits: 19 → $4 \\nmid 19$ ⇒ ❌ Rule for 5 A number is divisible by 5 if its last digit is either 0 or 5.\nExamples:\n$5 \\mid 205$ → Last digit is 5 ⇒ ✅ $5 \\nmid 128$ → Last digit is 8 ⇒ ❌ Rule for 6 A number is divisible by 6 if it is divisible by both 2 and 3.\nExamples:\n$6 \\mid 114$: Divisible by 2: last digit 4 is even ⇒ ✅ Divisible by 3: $1 + 1 + 4 = 6$ → $3 \\mid 6$ ⇒ ✅ $6 \\nmid 308$: Divisible by 2: 8 is even ⇒ ✅ Not divisible by 3: $3 + 0 + 8 = 11$ ⇒ ❌ Rule for 7 Take the last digit, double it, and subtract it from the rest of the number. If the result is divisible by 7, then the number is divisible by 7.\nExamples:\n$7 \\mid 672$:\n$67 - 2 \\times 2 = 63$ → $7 \\mid 63$ ⇒ ✅ $7 \\nmid 905$:\n$90 - 2 \\times 5 = 80$ → $7 \\nmid 80$ ⇒ ❌ Rule for 8 A number is divisible by 8 if the last three digits form a number divisible by 8.\nExamples:\n$8 \\mid 109816$:\nLast three digits: 816 → $8 \\mid 816$ ⇒ ✅ $8 \\nmid 216302$:\nLast three digits: 302 → $8 \\nmid 302$ ⇒ ❌ Rule for 9 A number is divisible by 9 if the sum of its digits is divisible by 9.\nExample:\n$9 \\mid 1629$:\n$1 + 6 + 2 + 9 = 18$ → $9 \\mid 18$ ⇒ ✅ Rule for 10 A number is divisible by 10 if it ends in 0.\nExamples:\n$10 \\mid 130$ → ends in 0 ⇒ ✅ $10 \\nmid 131$ → ends in 1 ⇒ ❌ Rule for 11 A number is divisible by 11 if the alternating sum of its digits (i.e., subtracting every other digit) is divisible by 11 or equals 0.\nExamples:\n$11 \\mid 3729$:\n$(3 + 2) - (7 + 9) = 5 - 16 = -11$ ⇒ $11 \\mid 11$ ⇒ ✅ $11 \\nmid 987$:\n$(9 + 7) - 8 = 16 - 8 = 8$ ⇒ $11 \\nmid 8$ ⇒ ❌ Rule for 12 A number is divisible by 12 if it is divisible by both 3 and 4.\nExamples:\n$12 \\mid 648$: $6 + 4 + 8 = 18$ ⇒ $3 \\mid 18$ Last two digits: 48 ⇒ $4 \\mid 48$\n⇒ ✅ $12 \\nmid 524$: $5 + 2 + 4 = 11$ ⇒ $3 \\nmid 11$\n⇒ ❌ Prime Numbers These are positive integers greater than 1 that are only divisible by 1 and themselves.\nExamples: 2, 3, 5, 7, 11, 13, …\nComposite Numbers Composite numbers are positive integers greater than 1 that are not prime.\nThey have more than two distinct positive divisors.\nExamples:\n4 → $2 \\times 2$ 9 → $3 \\times 3$ 12 → $2 \\times 2 \\times 3$ Greatest Common Divisor (GCD) The GCD of two or more integers is the largest positive integer that divides each of the numbers.\nDenoted as $\\gcd(a, b)$ Can be found using prime factorization or the Euclidean algorithm Example: GCD of 375 and 525 Prime factorization method:\n375 = $3 \\times 5^3$ 525 = $3 \\times 5^2 \\times 7$ Common factors: $3 \\times 5^2 = 75$\n⇒ $\\gcd(375, 525) = 75$\nEuclidean algorithm method:\nFormula: $a = bq + r$\nwhere\n$q$ is the quotient (the largest integer such that $bq \\le a$), $r = a - bq$ is the remainder. $525 = 375(1) + 150$ $375 = 150(2) + 75$ $150 = 75(2) + 0$ When the remainder is zero, the last nonzero remainder is the GCD:\n$$ \\gcd(375, 525) = 75 $$\nLeast Common Multiple (LCM) The LCM of two or more integers is the smallest number that is a multiple of all the given numbers.\nDenoted as $\\text{lcm}(a, b)$ Often found using prime factorization or the formula:\n$\\text{lcm}(a, b) = \\frac{a \\times b}{\\gcd(a, b)}$ Example:\nLCM of 12 and 18 $\\gcd(12, 18) = 6$ $\\text{lcm}(12, 18) = \\frac{12 \\times 18}{6} = 36$ Number Systems Decimal (Base 10) Digits: 0–9\nExample: 123, 45\nBinary (Base 2) Digits: 0, 1\nPrefix: 0b or 0x in some notations\nExample: 0b1010 (10 in decimal)\nOctal (Base 8) Digits: 0–7\nPrefix: 0o\nExample: 0o17 (15 in decimal)\nHexadecimal (Base 16) Digits: 0–9 and A–F (A=10, B=11, …, F=15)\nPrefix: 0x\nExample: 0x1F (31 in decimal)\nHere’s how to convert between different number systems using the Euclidean method. I’ll give examples for converting Decimal to Binary, Decimal to Octal, Decimal to Hexadecimal, and Binary to Decimal:\nNumber Systems Conversion Using the Euclidean Method 1. Decimal to Binary (Base 2) To convert a decimal number to binary, repeatedly divide the number by 2 and record the remainders. The binary number is the sequence of remainders read from bottom to top.\nExample 1: Decimal 13 to Binary\n13 ÷ 2 = 6, remainder 1 6 ÷ 2 = 3, remainder 0 3 ÷ 2 = 1, remainder 1 1 ÷ 2 = 0, remainder 1 Binary: 1101\nExample 2: …","date":1743431063,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1745761278,"objectID":"4a58c324abee91816e70afcecfb2ab86","permalink":"http://localhost:1313/post/divisibility-and-integers/","publishdate":"2025-03-31T22:24:23+08:00","relpermalink":"/post/divisibility-and-integers/","section":"post","summary":"Learn the basics of divisibility rules, prime and composite numbers, GCD, LCM, and how to convert numbers between different systems using simple methods.","tags":["Discrete Mathematics"],"title":"Divisibility and Number Theory: A Beginner’s Guide","type":"post"},{"authors":null,"categories":null,"content":"Understanding the difference between JavaScript’s == (loose equality) and === (strict equality) operators is crucial for writing reliable and predictable code. These operators are used to compare values, but they behave differently when it comes to type conversion.\nLoose Equality (==) The == operator compares two values for equality, performing type conversion if necessary. This means that if the values are of different types, JavaScript will attempt to convert them to a common type before making the comparison. While this can be convenient, it may lead to unexpected results due to implicit type coercion.\nExample 1: Comparing a number and a string\nlet a = 5; let b = \u0026#39;5\u0026#39;; console.log(a == b); // Output: true In this case, JavaScript converts the string \u0026#39;5\u0026#39; to the number 5 before making the comparison, resulting in true.\nExample 2: Comparing a boolean and a number\nlet x = 0; let y = false; console.log(x == y); // Output: true Here, false is coerced to 0, so the comparison evaluates to true.\nExample 3: Comparing null and undefined\nconsole.log(null == undefined); // Output: true JavaScript considers null and undefined equal when using ==, even though they are different types.\nStrict Equality (===) The === operator compares both the value and the type of the operands without performing any type conversion. For the comparison to return true, both the value and the type must be the same.\nExample 1: Comparing a number and a string\nlet a = 5; let b = \u0026#39;5\u0026#39;; console.log(a === b); // Output: false Since a is a number and b is a string, the comparison returns false because their types differ.\nExample 2: Comparing two identical strings\nlet str1 = \u0026#39;hello\u0026#39;; let str2 = \u0026#39;hello\u0026#39;; console.log(str1 === str2); // Output: true Both the value and type match, so the comparison returns true.\nExample 3: Comparing null and undefined\nconsole.log(null === undefined); // Output: false With ===, null and undefined are not considered equal because they are of different types.\nKey Differences Type Conversion: == performs type conversion to match the types before comparison, which can lead to unexpected results. === does not perform type conversion; both the value and type must match for the comparison to return true.\nPredictability: Using === is generally more predictable and less error-prone because it doesn’t involve implicit type coercion.\nBest Practices It’s advisable to use === (strict equality) over == (loose equality) to avoid unexpected type coercion issues. This practice leads to more reliable and maintainable code.\nFor more detailed information on equality comparisons in JavaScript, you can refer to the MDN Web Docs.\n","date":1743050382,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050677,"objectID":"5f446f833604e8d087c0cb9b66d3997c","permalink":"http://localhost:1313/post/what-is-the-triple-equal-operator-in-javascript/","publishdate":"2025-03-27T12:39:42+08:00","relpermalink":"/post/what-is-the-triple-equal-operator-in-javascript/","section":"post","summary":"Understanding the difference between JavaScript's == (loose equality) and === (strict equality) operators in javascript.","tags":["Programming","Javascript"],"title":"What Is the Triple Equal Operator in Javascript?","type":"post"},{"authors":null,"categories":null,"content":"Fixing “iwlwifi failed with error -110” on Linux After Dual Booting Dual booting Windows and Linux can be a great way to enjoy the best of both worlds. However, if you’re experiencing issues with your Intel Wi‑Fi card on Linux—especially when switching from Windows—the error message below might look familiar in your system logs:\n[ 6.397335] iwlwifi 0000:02:00.0: probe with driver iwlwifi failed with error -110 In this post, we’ll explore what this error means, why it may occur in a dual-boot setup, and a simple fix that worked for me.\nWhat Does “Error -110” Mean? When you see an error like this in your dmesg output, it tells you that the iwlwifi driver isn’t able to initialize your Intel Wireless 8265/8275 card properly. The “-110” error is often related to a hardware or power management issue. In many cases, this can happen because Windows leaves the Wi‑Fi card in a low-power or “hibernated” state if its Fast Startup feature is enabled.\nWhy Dual Boot Can Cause Wi‑Fi Problems Fast Startup in Windows:\nWindows Fast Startup (sometimes called Fast Boot) is designed to speed up the boot process by not completely shutting down the system. Instead, Windows saves some system state to disk so that the next boot is faster. While this feature can be helpful for Windows users, it may prevent your Wi‑Fi card from fully resetting its power state when you switch over to Linux. As a result, Linux may not detect or initialize the card correctly, triggering the error.\nWhat Happens in Linux:\nWhen you boot directly into Linux after using Windows, the leftover power state or “hibernation” mode on your Wi‑Fi hardware can lead to the driver failing its probe (or initialization), hence the error message we saw. Interestingly, if you boot into Windows first (which resets the hardware properly) and then switch to Linux, the card works fine.\nThe Simple Fix: Disable Windows Fast Startup After some troubleshooting, I discovered that disabling Windows Fast Startup resolved the problem permanently. Here’s how you can do it:\nBoot into Windows 10:\nOpen the Control Panel and go to Power Options. You can press Win + R, type control panel, and hit Enter to open it. Alternatively, if you’re using a laptop, you can right-click the battery icon in the taskbar to access power settings.\nAccess Shutdown Settings:\nClick on “Choose what the power buttons do” on the left-hand side.\nThen click on “Change settings that are currently unavailable” at the top.\nDisable Fast Startup:\nUnder the Shutdown settings section, uncheck the box next to “Turn on fast startup (recommended)”.\nSave and Reboot:\nClick Save changes and restart your computer.\nOnce you’ve disabled Fast Startup, the Wi‑Fi card resets fully when shutting down, allowing Linux to initialize it properly during boot. Now, when you check your system logs (using dmesg), the error should no longer appear, and your wireless connections should work without a hitch.\nHow to Confirm the Fix After making the changes, boot into Linux and run:\nsudo dmesg | grep -i iwlwifi If you no longer see the error message and your wireless interface appears in the output of:\nnmcli device status then you know the issue is resolved!\nIn Conclusion Dual boot setups can sometimes bring unexpected challenges, especially when different operating systems manage hardware power states in different ways. Disabling Windows Fast Startup is a simple and effective solution to the “iwlwifi failed with error -110” issue. By ensuring that your hardware resets completely during shutdown, you help Linux initialize your Wi‑Fi card correctly every time.\nIf you found this post helpful, feel free to share it with others who might be facing the same problem!\nHappy dual booting, and may your connections always be strong!\n","date":1742967852,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050434,"objectID":"cf6f9ff40516a96302b0443b4b73bf65","permalink":"http://localhost:1313/post/wififix/","publishdate":"2025-03-26T13:44:12+08:00","relpermalink":"/post/wififix/","section":"post","summary":"Fixing “iwlwifi failed with error -110” on Linux After Dual Booting with windows 10/11","tags":["Linux","Wifi"],"title":"Fixing 'iwlwifi failed with error -110' on Linux After Dual Boot with Windows","type":"post"},{"authors":null,"categories":null,"content":"Introduction Algorithms are step-by-step instructions designed to solve problems. They are the foundation of programming and computer science. Whether you’re sorting numbers, searching for data, or making a game character move, algorithms are everywhere.\nTo express algorithms clearly, we often use pseudocode—a simplified way to write logic without focusing on specific programming language syntax.\nIn this post, we’ll explore both simple and complex algorithms using pseudocode.\nSimple Example: Finding the Maximum of Two Numbers Let’s start with a basic problem: finding the larger of two numbers.\nPseudocode: Algorithm FindMax(A, B): If A \u0026gt; B Then Return A Else Return B Explanation: Compare A and B. Return the larger one. Example Execution: Input: A = 5, B = 9 Output: 9 More Complex Example: Bubble Sort Now, let’s look at something more challenging—Bubble Sort, an algorithm that sorts a list by repeatedly swapping adjacent elements if they are in the wrong order.\nPseudocode: Algorithm BubbleSort(Array): N = length of Array Repeat N-1 times: For i from 0 to N-2: If Array[i] \u0026gt; Array[i+1] Then Swap(Array[i], Array[i+1]) Explanation: Loop through the list multiple times. Compare adjacent elements. Swap them if they are in the wrong order. Repeat until the list is sorted. Example Execution: Input: [5, 3, 8, 4, 2]\nIterations: [3, 5, 4, 2, 8] [3, 4, 2, 5, 8] [3, 2, 4, 5, 8] [2, 3, 4, 5, 8] (Sorted!) Complexity: Worst case: O(n²) Best case (already sorted list): O(n) Conclusion Algorithms range from simple comparisons to complex sorting techniques. Learning to express them in pseudocode makes it easier to understand their logic before implementing them in programming languages.\nWant to learn more? Try implementing these in Python, Java, or C++!\n","date":1742649703,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1743050441,"objectID":"1441addfd4c611a506ab0108c90e180a","permalink":"http://localhost:1313/post/algo/","publishdate":"2025-03-22T21:21:43+08:00","relpermalink":"/post/algo/","section":"post","summary":"A beginner-friendly guide to understanding algorithms and pseudocode, with simple and complex examples.","tags":["Algorithm","Pseudocode"],"title":"Understanding Algorithms and Pseudocode","type":"post"}]